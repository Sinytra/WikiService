#include <fmt/args.h>
#include <fstream>
#include <regex>
#include <schemas/schemas.h>
#include <service/database/project_database.h>
#include <service/project/resolved.h>
#include <storage/gitops.h>

#define NO_ICON "_none"

#define H1_REGEX R"(^#\s+([^\n<>*_`]+)$)"

using namespace logging;
using namespace drogon;
using namespace drogon_model::postgres;
namespace fs = std::filesystem;

std::string getDocsTreeEntryName(std::string s) {
    if (s.ends_with(DOCS_FILE_EXT)) {
        s = s.substr(0, s.size() - 4);
    }
    return toCamelCase(s);
}

auto createDirEntriesComparator(const std::vector<std::string> &keys) {
    return [&keys](const fs::directory_entry &a, const fs::directory_entry &b) {
        if (keys.empty()) {
            return a.path().filename().string() < b.path().filename().string();
        }
        const auto aPos = std::ranges::find(keys, a.path().filename().string());
        const auto bPos = std::ranges::find(keys, b.path().filename().string());
        if (aPos == keys.end() && bPos == keys.end()) {
            return false;
        }
        if (aPos == keys.end()) {
            return false;
        }
        if (bPos == keys.end()) {
            return true;
        }

        const auto aIdx = std::distance(keys.begin(), aPos);
        const auto bIdx = std::distance(keys.begin(), bPos);
        return aIdx < bIdx;
    };
}

std::optional<std::string> readPageHeading(const std::string &filePath) {
    static const std::regex headingRegex(H1_REGEX, std::regex_constants::ECMAScript);

    std::ifstream ifs(filePath);
    if (!ifs) {
        return std::nullopt;
    }

    std::string line;
    while (std::getline(ifs, line)) {
        if (line.starts_with("# ")) {
            if (std::smatch match; std::regex_search(line, match, headingRegex)) {
                if (match.size() > 1) {
                    return match[1].str();
                }
            }
        } else if (line.starts_with("#")) {
            break;
        }
    }

    ifs.close();
    return std::nullopt;
}

std::string formatEditUrl(const Project &project, const std::string &filePath) {
    const auto provider = git::getGitProvider(project.getValueOfSourceRepo());
    if (!provider) {
        return "";
    }

    fmt::dynamic_format_arg_store<fmt::format_context> store;
    store.push_back(fmt::arg("branch", project.getValueOfSourceBranch()));
    store.push_back(fmt::arg("base", removeLeadingSlash(project.getValueOfSourcePath())));
    store.push_back(fmt::arg("path", removeTrailingSlash(filePath)));
    const auto result = vformat(provider->filePath, store);

    return removeTrailingSlash(project.getValueOfSourceRepo()) + "/" + result;
}

namespace service {
    ENUM_FROM_TO_STR(FileType, {FileType::FILE, "file"}, {FileType::DIR, "dir"})

    void to_json(nlohmann::json &j, const FileType &obj) { j = enumToStr(obj); }
    void from_json(const nlohmann::json &j, FileType &obj) { obj = parseFileType(j); }

    FolderMetadata ResolvedProject::getFolderMetadata(const fs::path &path) const {
        FolderMetadata metadata;
        if (!exists(path)) {
            return metadata;
        }

        std::ifstream ifs(path);
        const auto rel = relative(path, format_.getRoot());
        try {
            nlohmann::ordered_json parsed = nlohmann::ordered_json::parse(ifs);

            if (const auto error = validateJson(schemas::folderMetadata, parsed)) {
                logger.error("Invalid folder metadata: Project: {} Path: {} Error: {}", project_.getValueOfId(), path.string(), error->msg);

                issues_->addIssueAsync(ProjectIssueLevel::ERROR, ProjectIssueType::FILE, ProjectError::INVALID_FORMAT, error->msg, rel);
            } else {
                for (auto &[key, val]: parsed.items()) {
                    metadata.keys.push_back(key);

                    std::string name = "";
                    std::string icon = "";
                    if (val.is_string()) {
                        name = val;
                    } else if (val.is_object()) {
                        if (val.contains("name"))
                            name = val["name"].get<std::string>();
                        icon = val.contains("icon") ? (val["icon"].is_null() ? NO_ICON : val.value("icon", "")) : "";
                    } else {
                        throw std::runtime_error("Unexpected format");
                    }

                    // Fallback to page heading
                    if (name.empty()) {
                        const auto pagePath = rel.parent_path() / key;
                        name = getPageTitle(pagePath).value_or("");
                    }

                    // Last resort autogenerated title
                    if (name.empty()) {
                        name = getDocsTreeEntryName(key);
                    }

                    metadata.entries.try_emplace(key, name, icon);
                }
            }

            ifs.close();
        } catch (const nlohmann::json::parse_error &error) {
            ifs.close();
            logger_->error("Error parsing folder metadata: Project '{}', path {}", project_.getValueOfId(), path.string());
            logger_->error("JSON parse error (getFolderMetadata): {}", error.what());

            issues_->addIssueAsync(ProjectIssueLevel::ERROR, ProjectIssueType::FILE, ProjectError::INVALID_FILE, error.what(), rel);
        }
        return metadata;
    }

    FileTree ResolvedProject::getDirectoryTree(const fs::path &dir) const {
        FileTree root;

        const auto metaFilePath = format_.getFolderMetaFilePath(dir);
        auto [keys, entries] = getFolderMetadata(metaFilePath);

        std::vector<fs::directory_entry> paths;
        for (const auto &entry: fs::directory_iterator(dir)) {
            if (const auto fileName = entry.path().filename().string();
                (entry.is_directory() || entry.is_regular_file() && fileName.ends_with(DOCS_FILE_EXT)) && !fileName.starts_with(".") &&
                !fileName.starts_with("_"))
            {
                paths.push_back(entry);
            }
        }
        std::ranges::sort(paths, createDirEntriesComparator(keys));

        for (const auto &entry: paths) {
            const auto fileName = entry.path().filename().string();
            const auto relativePath = relative(entry.path(), format_.getRoot()).string();
            const auto isDirectory = entry.is_directory();
            const auto displayPath = isDirectory ? relativePath : relativePath.substr(0, relativePath.size() - 4);

            auto [name, icon] =
                entries.contains(fileName) ? entries[fileName] : FolderMetadataEntry{getPageTitle(relativePath).value_or(""), ""};
            if (name.empty()) {
                name = getDocsTreeEntryName(fileName);
            }

            FileTreeEntry obj;
            obj.name = name;
            obj.icon = icon;
            obj.path = displayPath;
            obj.type = isDirectory ? FileType::DIR : FileType::FILE;
            if (isDirectory) {
                FileTree children = getDirectoryTree(entry.path());
                obj.children = children;
            }
            root.push_back(obj);
        }

        return root;
    }

    std::optional<std::string> ResolvedProject::getPagePath(const std::string &path) const {
        const auto filePath = format_.getLocalizedFilePath(removeLeadingSlash(path) + DOCS_FILE_EXT);
        if (!exists(filePath))
            return std::nullopt;
        return relative(filePath, docsDir_).string();
    }

    std::optional<std::string> ResolvedProject::getPageTitle(const std::string &path) const {
        if (const auto frontmatter = readPageAttributes(path); frontmatter && !frontmatter->title.empty()) {
            return frontmatter->title;
        }
        return readPageHeading(format_.getLocalizedFilePath(removeLeadingSlash(path)));
    }

    TaskResult<ProjectPage> ResolvedProject::readPageFile(std::string path) const {
        const auto filePath = format_.getLocalizedFilePath(removeLeadingSlash(path));

        std::ifstream file(filePath);

        if (!file) {
            return {Error::ErrNotFound};
        }

        std::stringstream buffer;
        buffer << file.rdbuf();

        file.close();

        const auto editUrl = formatEditUrl(project_, path);

        return {ProjectPage{.content = buffer.str(), .editUrl = editUrl}};
    }

    Task<TaskResult<ProjectPage>> ResolvedProject::readContentPage(const std::string id) const {
        const auto contentPath = co_await projectDb_->getProjectContentPath(id);
        if (!contentPath) {
            co_return {Error::ErrNotFound};
        }
        co_return readPageFile(*contentPath);
    }

    Task<TaskResult<FileTree>> ResolvedProject::getDirectoryTree() { co_return getDirectoryTree(docsDir_); }

    Task<> validatePageFile(const FileTreeEntry &entry, const ResolvedProject &resolved,
                            const std::shared_ptr<ProjectIssueCallback> &issues, const std::vector<std::string> &requiredAttributes) {
        const auto path = entry.path + DOCS_FILE_EXT;
        if (const auto title = resolved.getPageTitle(path); !title) {
            co_await issues->addIssue(ProjectIssueLevel::WARNING, ProjectIssueType::FILE, ProjectError::NO_PAGE_TITLE, "", path);
        }

        const auto frontmatter = resolved.readPageAttributes(path);

        if (const auto pageAttributes = resolved.readPageAttributes(path)) {
            const std::unordered_map<std::string, std::string> attributes = {
                {"id", pageAttributes->id}, {"title", pageAttributes->title}, {"icon", pageAttributes->icon}};

            for (const auto &attr: requiredAttributes) {
                if (!attributes.contains(attr) || attributes.find(attr)->second.empty()) {
                    co_await issues->addIssue(ProjectIssueLevel::WARNING, ProjectIssueType::FILE, ProjectError::MISSING_REQUIRED_ATTRIBUTE,
                                              attr, path);
                }
            }
        }
    }

    Task<> validatePagesTree(const FileTree &tree, const ResolvedProject &resolved, const std::shared_ptr<ProjectIssueCallback> &issues,
                           const std::vector<std::string> &requiredAttributes) {
        for (const auto &entry: tree) {
            if (entry.type == FileType::FILE) {
                co_await validatePageFile(entry, resolved, issues, requiredAttributes);
            } else if (entry.type == FileType::DIR) {
                co_await validatePagesTree(entry.children, resolved, issues, requiredAttributes);
            }
        }
    }

    Task<> ResolvedProject::validatePages() {
        const auto tree = co_await getDirectoryTree();
        co_await validatePagesTree(*tree, *this, issues_, {});

        const auto contentTree = co_await getProjectContents();
        co_await validatePagesTree(*contentTree, *this, issues_, {"id"});
    }
}
